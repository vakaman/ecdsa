---
title: "Al√©m do C√≥digo: Redes de Computadores para Desenvolvedores"
seoTitle: "Al√©m do C√≥digo: Redes de Computadores para Desenvolvedores"
seoDescription: "Conceitos e pr√°ticas de redes que todo programador deve dominar."
datePublished: Sat Jan 18 2025 03:02:43 GMT+0000 (Coordinated Universal Time)
cuid: cm61lsbr8000608jv83wd5ag7
slug: alem-do-codigo-redes-de-computadores-para-desenvolvedores
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1735562551381/03c7b308-2d6f-4ffa-b7be-ca288eed6834.webp
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1737169339536/389415cd-a49a-47fd-80cf-7a7efdd2bc5f.webp
tags: docker-network, linux-networking, broadcast, tcpip, upnp, ssdp

---

---

# Resumo

Hoje em dia utilizamos muito o conceito de cont√¢iner e junto com ele nos obrigamos a entender mais sobre essa tecnologia e querendo ou n√£o precisamos entender ao menos um pouco sobre redes. Esse artigo vai focar no m√≠nimo que voc√™ precisa entender sobre redes para conseguir se sentir mais confort√°vel quando o assunto for TCP/IP.

Voc√™ vai encontrar os c√≥digos apresentados aqui, no repositorio baixo:

‚Üí [https://github.com/vakaman/Alem-do-Codigo-Redes-de-computador-para-desenvolvedores](https://github.com/vakaman/Alem-do-Codigo-Redes-de-computador-para-desenvolvedores)

---

# Por que entender redes √© essencial para o sucesso do seu c√≥digo?

---

J√° de antem√£o e para ser bem sincero, pro seu c√≥digo em s√≠, n√£o muda muita coisa n√£o, talvez em algum momento voc√™ tenha alguns insites interessantes por j√° ter visto uma abstra√ß√£o parecida em algum protocolo de rede.

Isso significa que redes n√£o s√£o um problema seu? N√£o! e eu posso provar.

Hoje vivemos na era dos containers e nos comunicamos com eles frequentemente atrav√©s de redes TCP/IP, sendo assim‚Ä¶ se voc√™ quer se manter longe de problemas quando o assunto √© redes vem comigo, mas antes‚Ä¶ vamos passar pelo b√°sico.

Antes de come√ßar, um ponto que acho interessante refor√ßar √©‚Ä¶ se voc√™ se sente confort√°vel com o conhecimento de redes que tem hoje e o que eu falei anteriormente refor√ßa a sua ideia de que voc√™ j√° sabe o suficiente, n√£o continue, talvez n√£o fa√ßa sentido de fato para voc√™. Agora‚Ä¶ se voc√™ quer desbravar algo que ainda n√£o teve a oportunidade de ter contato, eu fico feliz e te desejo uma boa leitura.

# Dom√≠nios de sub-rede

Imagine um cen√°rio onde um grupo de computadores precisa se comunicar, por√©m para que isto seja poss√≠vel, um padr√£o deve ser definido, uma das regras deste padr√£o √© que cada um que entre neste grupo n√£o possa ter identificadores duplicados. Outra regra importante √© que os grupos t√™m tamanhos fixos e previamente definidos. Com isto em mente vou tentar explicar de uma forma did√°tica o m√≠nimo que voc√™ precisa saber para entender o conceito.

Aposto que voc√™ j√° viu algumas destas redes 10.0.0.1/24, 192.168.0.0/24, 172.31.0.0/24, e isto se d√° pelo fato de serem redes utilizadas dentro do que chamamos rede local, para os exemplos √† seguir vou utiliza o prefixo 192.168.0.0/24, mas o conceito se aplica para todos os prefixos do protocolo IP.

Dentro do prefixo 192.168.0.0/24 temos 255 posi√ß√µes, imagine que cada posi√ß√£o pode ser ocupada por um computador com exce√ß√£o das reservadas.

Mas‚Ä¶ como eu sei que s√£o 255? que define isso? ü§î

A m√°scara de sub-rede, que neste caso √© o /24. Mais um nome estranho n√©? eu sei‚Ä¶eu sei‚Ä¶ calma‚Ä¶ vamos por partes. Vamos passar pelos nomes logo abaixo, vai ficar f√°cil entender, confia.

| **Host** | pode ser muitas coisas, desde sua televis√£o ao um cont√¢iner do postgresql | Um dispositivo ou um servi√ßo. Todos que tem suporte ao protocolo tcp/ip podem ser considerados um host. |
| --- | --- | --- |
| **IP** | 192.168.0.0 ou 192.168.0.239 ou 1.1.1.1 | Um √∫nico endere√ßo, a unidade de fato, o identificador de um host em uma rede. |
| **Mascara de sub-rede** | 255.255.255.0 ou simplesmente /24 | A defini√ß√£o dos limites, onde termina uma rede. |
| **Prefixo ou Rede** | 192.168.0.0/24 | A jun√ß√£o do IP com a m√°scara de sub-rede, define os limites da rede com os dois sabemos onde inicia e onde termina o range dos IP‚Äôs daquele dom√≠nio. |

Quando definimos as fronteiras de uma rede, estamos estabelecendo um grupo onde todos os participantes podem se comunicar de forma direta ou seja

O host com o IP 192.168.0.10/24 pode se comunicar com o host 192.168.10.11/24 se a necessidade de ou terceiro elemento. Caso algum destes host queira se comunicar com o endere√ßo 10.0.0.10 ele precisa passar por um roteador, mas‚Ä¶ da√≠ √© uma longa hist√≥ria, vou tentar ir pelo caminho mais curto.

Se sabemos que o endere√ßo 192.168.0.0/24 possui 255 ips e alguns s√£o reservados, quais eu n√£o posso usar?

`NO | 192.168.0.0 ‚Üí rede ( define o inicio da rede )`

`NO | 192.168.0.1 ‚Üí gateway ( normalmente um roteador, ele conecta a rede local com outras redes)`

`YES | 192.168.0.2-254 ‚Üí livre para aloca√ß√£o ( posi√ß√µes que podemos utilizar )`

`NO | 192.168.0.255 ‚Üí broadcast ( envia mensagens para todos na mesma sub-rede simultaneamente )`

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1736290837064/bc734db0-fab2-4a95-8bad-4dcc8b32afac.png align="center")

Normalmente o que vemos em nossas casas √© algo parecido com o desenho acima, onde temos um roteador e diversos hosts, cada um deles cont√©m sua tabela de rotas, onde atrav√©s dela os hosts sabem qual a rede que eles fazem parte e para quem ele precisa perguntar nos casos onde ele n√£o conhece a rede.

Ok, ok tudo muito bonito e tals, mas‚Ä¶ oq isso tem a ver com os containers?

Pois ent√£o‚Ä¶ os containers fazem parte de uma sub-rede, e eles s√≥ conseguem se comunicar se estiverem na mesma rede e com permiss√£o para tal.

---

# O que √© e pra que servem as portas?

De forma simplista as portas TCP t√™m a fun√ß√£o de criar um canal de comunica√ß√£o entre dois hosts. Essa conex√£o √© associada a um processo, mas‚Ä¶ se acalme que a gente vai chegar l√° e voc√™ vai conseguir entender o que isso significa.

Existem 65535 portas TCP dispon√≠veis, entretanto, existe uma organiza√ß√£o separando as portas para cada contexto, vamos passar brevemente por esta separa√ß√£o

| **FUN√á√ÉO** | **RANGE** | **DETALHE** |
| --- | --- | --- |
| [WELL KNOWN PORT](https://datatracker.ietf.org/doc/html/rfc1340#page-9) | 0-1023 | S√£o portas utilizadas por sistemas e ou processos root |
| [REGISTERED PORT](https://datatracker.ietf.org/doc/html/rfc1340#page-23) | 1024-49151 | Portas registradas s√£o usadas no TCP e listadas pela IANA como conveni√™ncia, mas n√£o s√£o controladas. |
| [PRIVATE OR EPHEMETAL PORTS](https://www.rfc-editor.org/rfc/rfc6335#section-6) | 49152-65535 | Atribu√≠das dinamicamente para conex√µes tempor√°rias |

Vamos simular o cen√°rio abaixo, para fazer com que o host A, crie uma conex√£o com o host B atrav√©s das portas TCP.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1737292199836/02d48fb3-d798-4c42-9a1c-811671d6bfc2.png align="center")

Como podemos ver, temos um servidor, que chamamos de host\_a\_server, ele tem um processo PID 1, escutando na porta 6969.

J√° do outro lado, temos um segundo elemento que chamamos de host\_b\_client, que dever√° iniciar uma requisi√ß√£o para o servidor com destino a porta 6969 do servidor e para que a conex√£o seja estabelecida uma porta de origem √© associada a esta conex√£o.

Assim que rodamos o projeto, vamos ver este comportamento.

```apache
host_a_server  | 2025-01-19 13:05:16,795 - INFO - Iniciando servidor...
host_a_server  | 2025-01-19 13:05:16,795 - INFO - Servidor escutando na porta 6969...

host_b_client  | 2025-01-19 13:05:17,028 - INFO - Tentando conectar ao servidor host_a_server:6969...
host_b_client  | 2025-01-19 13:05:17,029 - INFO - Cliente conectado ao servidor host_a_server:6969
host_b_client  | 2025-01-19 13:05:17,029 - INFO - Mensagem enviada ao servidor.

host_a_server  | 2025-01-19 13:05:17,029 - INFO - Conex√£o estabelecida com ('1.2.9.3', 44890)

host_b_client  | 2025-01-19 13:05:17,029 - INFO - Resposta do servidor: Ol√°, cliente! Conex√£o estabelecida.
host_b_client  | 2025-01-19 13:05:17,029 - INFO - Conex√£o com o servidor encerrada.

host_a_server  | 2025-01-19 13:05:17,029 - INFO - Mensagem recebida: Ol√°, servidor!
host_a_server  | 2025-01-19 13:05:17,029 - INFO - Conex√£o com ('1.2.9.3', 44890) encerrada.
```

Podemos ver no container do servidor, que o mesmo est√° com uma porta listen no endere√ßo 0.0.0.0, ou seja, a porta 6969 est√° dispon√≠vel em qualquer uma das interfaces que o servidor possuir.

```apache
root@host_a_server:/app# netstat -nat
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:6969            0.0.0.0:*               LISTEN
```

Um ponto importante que vale ressaltar √© que no contexto TCP/IP, precisamos entender que existem IP‚Äôs de origem e destino e portas de origem e destino para uma conex√£o estabelecida, ou seja, o IP e porta de origem de um host se comunica com o IP e porta de destino de outro host, esse processo acontece atrav√©s do [3-way-handshake](https://gitbook.ganeshicmc.com/redes/three-way-handshake), mas n√£o vou evoluir o assunto para este caminho, em todo caso se quiser mais detalhes, deixei nas refer√™ncias um material falando do assunto.

---

# Vamos falar de docker

Aposto que voc√™ j√° teve algum contato com docker, por√©m m√°gicamente meio que‚Ä¶ em um cen√°rio ideal, tudo meio que funciona certo?

Vamos pensar em um cen√°rio onde temos uma aplica√ß√£o, seja ela em PHP, Python, Js, tanto faz, vamos chamar ela de APP, um banco de dados, neste caso vou chamar de DB, e um servi√ßo de cache, que simplesmente vou chamar de cache, o docker-compose dele ser√° algo parecido com isso.

```yaml
services:
    app:
        image: nginx:latest
        container_name: app
    db:
        image: mysql:latest
        container_name: db
        environment:
            MYSQL_ROOT_PASSWORD: root
            MYSQL_DATABASE: app
            MYSQL_USER: bad_user
            MYSQL_PASSWORD: bad_pass
    cache:
        image: redis:latest
        container_name: cache
```

Voc√™ vai perceber que se tentar subir estes servi√ßos, cada um de forma isolada vai funcionar, por√©m n√£o v√£o conseguir se comunicar, isso porque para que os servi√ßos possam se comunicar, precisamos que eles fa√ßam parte da mesma rede, lembra?

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1736291752618/ab7237fd-838d-417e-aaf9-5aaed578ce67.png align="center")

### Verificando a rede dos containers

Assim que subimos os servi√ßos, cada um dos hosts/containers v√£o ter seu pr√≥prio endere√ßo de IP, vamos verificar qual endere√ßo foram associados utilizando o comando do docker em conjunto com o [jq](https://jqlang.github.io/jq/download/) abaixo:

```bash
## Apenas comando do docker
docker container inspect app

## Comando do docker filtrando com jq a configura√ß√£o de Network
docker container inspect app | jq '.[0].NetworkSettings'
```

Utilizando o comando acima, conseguimos ver que o endere√ßo que o host (app) recebeu foi o endere√ßo:

**HOST:** 1.2.7.2/24

```json
{
  "Bridge": "",
  "SandboxID": "210f0e9ba9e77201d7e0f3a2948ce31826353c4727d8f45c0bcabb6bf5b020ac",
  "SandboxKey": "/var/run/docker/netns/210f0e9ba9e7",
  "Ports": {
    "80/tcp": null
  },
  "HairpinMode": false,
  "LinkLocalIPv6Address": "",
  "LinkLocalIPv6PrefixLen": 0,
  "SecondaryIPAddresses": null,
  "SecondaryIPv6Addresses": null,
  "EndpointID": "",
  "Gateway": "",
  "GlobalIPv6Address": "",
  "GlobalIPv6PrefixLen": 0,
  "IPAddress": "",
  "IPPrefixLen": 0,
  "IPv6Gateway": "",
  "MacAddress": "",
  "Networks": {
    "redes-docker_default": {
      "IPAMConfig": null,
      "Links": null,
      "Aliases": [
        "app",
        "app"
      ],
      "MacAddress": "02:42:01:02:07:02",
      "DriverOpts": null,
      "NetworkID": "961d9113f94092827308148af99793a9ea3d471716a14979b3dcce6683cd5b66",
      "EndpointID": "52e065cd20596fae04409ad82488297ba659c483b42527df4445e3b595533cae",
      "Gateway": "1.2.7.1",
      "IPAddress": "1.2.7.2",
      "IPPrefixLen": 24,
      "IPv6Gateway": "",
      "GlobalIPv6Address": "",
      "GlobalIPv6PrefixLen": 0,
      "DNSNames": [
        "app",
        "5ec26cac5ce0"
      ]
    }
  }
}
```

Continuando a inspe√ß√£o, chegamos no seguinte resultado.

| Servi√ßo | IP/PREFIX | GATEWAY |
| --- | --- | --- |
| app | 1.2.7.2/24 | 1.2.7.1 |
| db | 1.2.7.3/24 | 1.2.7.1 |
| cache | 1.2.7.4/24 | 1.2.7.1 |

Ou seja

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1737157963383/c4aa4d5a-2f6e-4b06-97cd-31965b022880.png align="center")

Ok, ok‚Ä¶ ent√£o significa que a aplica√ß√£o consegue falar com o banco de dados e consequentemente a aplica√ß√£o tamb√©m consegue falar com o cache, pois os mesmos est√£o na mesma rede certo?

Exatamente isso üëèüëèüëè, obviamente que para o contexto do docker existem restri√ß√µes a n√≠vel de firewall que podem fazer com que os hosts n√£o se comuniquem, mas‚Ä¶ com o docker-compose.yaml que eu utilizei e com o Docker Compose version v2.20.3 e o docker Docker version 27.3.1, build ce12230. Assim que eu subi a aplica√ß√£o, o docker utilizou a rede ‚Üí redes-docker\_default que est√° em modo bridge, permitindo a comunica√ß√£o entre os servi√ßos que fazem parte desta rede.

para inspecionar essa rede voc√™ pode utilizar o comando

```bash
~ docker network inspect redes-docker_default | jq '.[0].IPAM'
{
  "Driver": "default",
  "Options": null,
  "Config": [
    {
      "Subnet": "1.2.7.0/24",
      "Gateway": "1.2.7.1"
    }
  ]
}
```

Ao tentar [pingar](https://pt.wikipedia.org/wiki/Ping), do host da aplica√ß√£o para o host do banco de dados, percebemos que existe uma resposta. Chegamos a conclus√£o de que a comunica√ß√£o existe pois o ping informa quantos pacotes foram transmitidos e quantos destes foram recebidos.

```bash
### Acessando o container
~ docker exec -it app bash

### Testando a comunica√ß√£o
root@app:/# apt-get install -y iputils-ping
root@app:/# ping db
PING db (1.2.7.3) 56(84) bytes of data.
64 bytes from db.redes-docker_default (1.2.7.3): icmp_seq=1 ttl=64 time=0.184 ms
64 bytes from db.redes-docker_default (1.2.7.3): icmp_seq=2 ttl=64 time=0.077 ms
64 bytes from db.redes-docker_default (1.2.7.3): icmp_seq=3 ttl=64 time=0.064 ms
64 bytes from db.redes-docker_default (1.2.7.3): icmp_seq=4 ttl=64 time=0.076 ms
64 bytes from db.redes-docker_default (1.2.7.3): icmp_seq=5 ttl=64 time=0.076 ms
64 bytes from db.redes-docker_default (1.2.7.3): icmp_seq=6 ttl=64 time=0.075 ms
^C
--- db ping statistics ---
6 packets transmitted, 6 received, 0% packet loss, time 5138ms
rtt min/avg/max/mdev = 0.064/0.092/0.184/0.041 ms
```

Em algumas situa√ß√µes, os hosts negam as requisi√ß√µes ICMP, fazendo com que o ping seja retornado, neste caso podemos utilizar o telnet, assim validamos se existe algum servi√ßo escutando na porta informada.

```bash
root@app:/# telnet db 3306
Trying 1.2.7.3...
Connected to db.
Escape character is '^]'.
I
5}lNTcaching_sha2_password2#08S01Got timeout reading communication packetsConnection closed by foreign host.
```

Mais uma forma de testar conectividade √© utilizando o [nmap](https://nmap.org/). Com ele podemos n√£o s√≥ testar uma porta, mas tamb√©m quais as portas abertas de um host.

```bash
root@app:/# nmap -p 3306 db
Starting Nmap 7.93 ( https://nmap.org ) at 2025-01-18 00:11 UTC
Nmap scan report for db (1.2.7.3)
Host is up (0.00011s latency).
rDNS record for 1.2.7.3: db.redes-docker_default

PORT     STATE SERVICE
3306/tcp open  mysql
MAC Address: 02:42:01:02:07:03 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 0.30 seconds
```

---

# Bora aprofundar?

Sendo bem transparente com voc√™, o b√°sico j√° passou e talvez‚Ä¶ apenas com o que eu falei acima j√° d√° pra ter uma boa no√ß√£o de como a rede dos containers funciona e tamb√©m, arrisco a dizer que‚Ä¶ √© um b√°sico do b√°sico de redes. Os mais entendidos do assunto sabem que tem bastante coisa pra falar ainda, mas‚Ä¶ agora vamos dar uma aprofundada üòâüëå

## Dom√≠nios de broadcast

Assim como no mundo da camada 3 do modelo TCP/IP existe um identificador √∫nico que chamamos de IP e definimos uma rede atrav√©s dos prefixos, fazendo com que os hosts participantes das redes possam se comunicar, na camada 2 tamb√©m existe um identificador √∫nico que chamamos de MAC ou endere√ßo f√≠sico e tamb√©m podem se comunicar MAC‚Äôs que participam do dom√≠nio de broadcast. Partindo disso vamos ver os mesmos hosts de antes de uma perspectiva diferente.

Primeiramente, vamos ver todas as interfaces que fazem parte do dom√≠nio de broadcast da rede ‚Üí redes-docker\_default, para isso precisamos saber qual bridge foi criada pelo docker.

```bash
docker network ls | grep redes-docker_default
NETWORK ID     NAME                         DRIVER    SCOPE
961d9113f940   redes-docker_default         bridge    local
```

Com o comando acima, chegamos no NETWORK ID 961d9113f940, o docker cria uma bridge com o mesmo id, por√©m com o prefixo ‚Äúbr-‚Äù, conseguimos ver as interfaces virtuais associadas a bridge criada com o seguinte comando.

```bash
> ip link show master br-961d9113f940
39: vethbf30c22@if38: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master br-961d9113f940 state UP mode DEFAULT group default
    link/ether b6:62:83:bd:3c:88 brd ff:ff:ff:ff:ff:ff link-netnsid 0
43: veth512189f@if42: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master br-961d9113f940 state UP mode DEFAULT group default
    link/ether ce:c0:66:fb:7a:a9 brd ff:ff:ff:ff:ff:ff link-netnsid 2
45: vethb57ac2a@if44: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master br-961d9113f940 state UP mode DEFAULT group default
    link/ether 5a:6a:f4:78:1c:9d brd ff:ff:ff:ff:ff:ff link-netnsid 1
```

Assim chegamos nos seguintes endere√ßos fisicos associados a bridge.

`b6:62:83:bd:3c:88`

`ce:c0:66:fb:7a:a9`

`5a:6a:f4:78:1c:9d`

Bora descobrir quem √© cada um?

Primeiramente precisamos entender que o docker relaciona uma interface virtual externa ao container com uma interface f√≠sica dentro do container atrav√©s do [veth pair](https://man7.org/linux/man-pages/man4/veth.4.html), onde uma esp√©cie de t√∫nel √© criado, relacionando essas duas interfaces.

Vamos acessar o container e verificar qual o endere√ßo mac est√° associado a ela e o indice externo que ela recebeu.

```bash
‚ùØ docker exec -it app bash
root@5ec26cac5ce0:/# ip link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
38: eth0@if39: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default
    link/ether 02:42:01:02:07:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
```

Podemos ver que o mac do host app internamente √© `02:42:01:02:07:02` e o √≠ndice associado a ele √© o 39, podemos ver isto pois logo ap√≥s o eth0 temos o `@if39`. Com esta informa√ß√£o em mente, vamos sair do container e verificar qual √© a interface associada a bridge que est√° relacionada a interface do container.

Primeiramente, vamos localizar a interface com o √≠ndice 39, e ent√£o partindo da informa√ß√£o da interface virtual, vamos chegar at√© o endere√ßo mac associado a ela.

```bash
### Localizando interface
ip link | grep "^39:"
39: vethbf30c22@if38: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master br-961d9113f940 state UP mode DEFAULT group default

### Verificando o MAC da interface
ip link show dev vethbf30c22
39: vethbf30c22@if38: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master br-961d9113f940 state UP mode DEFAULT group default
    link/ether b6:62:83:bd:3c:88 brd ff:ff:ff:ff:ff:ff link-netnsid 0
```

Assim conseguimos descobrir que, o endere√ßo MAC `b6:62:83:bd:3c:88` √© na verdade do container app, e que o endere√ßo mac que aparece na bridge na verdade est√° fazendo o papel de conectar a interface externa com o endere√ßo f√≠sico `b6:62:83:bd:3c:88` a interface eth0 interna com o endere√ßo `02:42:01:02:07:02`

Caso voc√™ queira inspecionar diretamente a bridge que foi gerenciada pelo docker, podemos utilizar o comando abaixo

```bash
> docker network inspect redes-docker_default | jq .[0].Containers
```

O resultado ser√° o seguinte

```json
{
  "4a51cc332df584771fd3ec8d5c229073b1971d2167d3385cd9376ee0b7761a04": {
    "Name": "db",
    "EndpointID": "2be625310559ed29d7d9571f30f43668cc86c0f14612eb0e90ebffd1d51d88e3",
    "MacAddress": "02:42:01:02:07:03",
    "IPv4Address": "1.2.7.3/24",
    "IPv6Address": ""
  },
  "5ec26cac5ce0ddbb299aca8368b7ca77d9149b1ea378e5949b9092c4fa93e586": {
    "Name": "app",
    "EndpointID": "52e065cd20596fae04409ad82488297ba659c483b42527df4445e3b595533cae",
    "MacAddress": "02:42:01:02:07:02",
    "IPv4Address": "1.2.7.2/24",
    "IPv6Address": ""
  },
  "ad888d9e5cbd6a84d868d574b94744d16ef853711e5c4dcbaad4007e07eebd31": {
    "Name": "cache",
    "EndpointID": "ad7604bd382e4f7480303a1b2ca6e9f414af7b3fa54af8c4e5646c35af8a6bdf",
    "MacAddress": "02:42:01:02:07:04",
    "IPv4Address": "1.2.7.4/24",
    "IPv6Address": ""
  }
}
```

Assim conseguimos ver todos os MAC‚Äôs associados aos containers.

---

# **Internet das Coisas (IoT)**

Para os Dev‚Äôs que chegaram at√© aqui‚Ä¶ bora falar de uma coisa muito legal que √© internet das coisas, e‚Ä¶ eu aposto que voc√™ em algum momento j√° se perguntou‚Ä¶ u√©? mas como que o meu celular sabe que a minha TV est√° na minha casa? ou‚Ä¶ como a Alexa sabe que existe uma l√¢mpada ou uma c√¢mera de vigil√¢ncia? Pois ent√£o meu amigo‚Ä¶ o mundo do dev que conhece redes tamb√©m √© muito legal, vem comigo.

Primeiramente a gente precisa entender que n√£o √© somente o broadcast que ajuda a gente com o processo de descoberta, afinal o broadcast tem como funcionalidade principal, enviar uma mensagem para todos os participantes de uma rede.

Algumas estrat√©gias envolvem:

[Broadcast](https://en.wikipedia.org/wiki/Broadcasting_\(networking\))

[Multicast](https://pt.wikipedia.org/wiki/Multicast)

[UPNP ‚Üí SSDP (Simple Service Discovery Protocol)](https://en.wikipedia.org/wiki/Simple_Service_Discovery_Protocol)

### Para a descoberta usando Broadcast

Neste exemplo abaixo, vamos fazer com que dois hosts se identifiquem atrav√©s de broadcast, vou utilizar Python, mas tenho certeza que voc√™ vai encontrar algo na sua linguagem de prefer√™ncia.

#### docker-compose.yaml

```yaml
services:
  device1:
    build: .
    container_name: device1
    environment:
      - DEVICE_NAME=Device1
    networks:
      iot_network:
        ipv4_address: 192.168.1.10

  device2:
    build: .
    container_name: device2
    environment:
      - DEVICE_NAME=Device2
    networks:
      iot_network:
        ipv4_address: 192.168.1.11

networks:
  iot_network:
    driver: bridge
    ipam:
      config:
        - subnet: 192.168.1.0/24
```

#### dockerfile

```dockerfile
FROM python:3.9-slim

WORKDIR /app
COPY broadcast.py /app/broadcast.py
RUN pip install --no-cache-dir --upgrade pip

CMD ["python", "/app/broadcast.py"]
```

#### [broadcast.py](http://broadcast.py)

```python
import socket
import threading
import time

BROADCAST_IP = "255.255.255.255"
PORT = 5005
DEVICE_NAME = "IoT Device"

discovered_devices = set()
stop_discovery = threading.Event()


def broadcast_sender():
    with socket.socket(
        socket.AF_INET,
        socket.SOCK_DGRAM,
        socket.IPPROTO_UDP
    ) as sender_socket:
        sender_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        while not stop_discovery.is_set():
            message = f"DISCOVER from {DEVICE_NAME}"
            print(f"[{DEVICE_NAME}] Enviando broadcast: {message}")
            sender_socket.sendto(message.encode(), (BROADCAST_IP, PORT))
            time.sleep(5)


def broadcast_receiver():
    with socket.socket(
        socket.AF_INET,
        socket.SOCK_DGRAM,
        socket.IPPROTO_UDP
    ) as receiver_socket:
        receiver_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        receiver_socket.bind(("", PORT))
        print(f"[{DEVICE_NAME}] Aguardando mensagens de broadcast "
              f"na porta {PORT}...")

        while not stop_discovery.is_set():
            message, address = receiver_socket.recvfrom(1024)
            decoded_message = message.decode()
            sender_ip = address[0]

            print(f"[{DEVICE_NAME}] Recebeu mensagem de {sender_ip}: "
                  f"{decoded_message}")

            if (sender_ip not in discovered_devices and
                    "DISCOVER" in decoded_message):
                discovered_devices.add(sender_ip)
                print(f"[{DEVICE_NAME}] Dispositivo descoberto: {sender_ip}")

                response = f"Hello from {DEVICE_NAME}!"
                print(f"[{DEVICE_NAME}] Respondendo a {sender_ip}: {response}")
                receiver_socket.sendto(response.encode(), address)

                stop_discovery.set()


if __name__ == "__main__":
    threading.Thread(target=broadcast_receiver, daemon=True).start()
    broadcast_sender()
```

O retorno da execu√ß√£o do exemplo ac√≠ma vai ser o seguinte

```bash
device2  | [IoT Device] Enviando broadcast: DISCOVER from IoT Device
device2  | [IoT Device] Aguardando mensagens de broadcast na porta 5005...
device2  | [IoT Device] Recebeu mensagem de 192.168.1.11: DISCOVER from IoT Device
device2  | [IoT Device] Dispositivo descoberto: 192.168.1.11
device2  | [IoT Device] Respondendo a 192.168.1.11: Hello from IoT Device!

device1  | [IoT Device] Enviando broadcast: DISCOVER from IoT Device
device1  | [IoT Device] Aguardando mensagens de broadcast na porta 5005...
device1  | [IoT Device] Recebeu mensagem de 192.168.1.10: DISCOVER from IoT Device
device1  | [IoT Device] Dispositivo descoberto: 192.168.1.10
device1  | [IoT Device] Respondendo a 192.168.1.10: Hello from IoT Device!

device2 exited with code 0
device1 exited with code 0
```

### Para descoberta UPNP

#### dockerfile

```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY upnp_discovery.py /app/upnp_discovery.py

RUN pip install --no-cache-dir --upgrade pip

CMD ["python", "/app/upnp_discovery.py"]
```

#### docker-compose.yaml

```yaml
services:
  device3:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: device3
    environment:
      - DEVICE_NAME=Device3

  device4:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: device4
    environment:
      - DEVICE_NAME=Device4

networks:
  default:
    driver: bridge
```

#### upnp\_[discovery.py](http://discovery.py)

```python
import socket
import threading
import time

MULTICAST_IP = "239.255.255.250"
PORT = 1900
DEVICE_NAME = "UPnP Device"
SERVICE_TYPE = "ssdp:all"
MX = 2

discovered_devices = set()
stop_discovery = threading.Event()


def ssdp_sender():
    with socket.socket(
        socket.AF_INET,
        socket.SOCK_DGRAM,
        socket.IPPROTO_UDP
    ) as sender_socket:
        sender_socket.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)
        message = (
            "M-SEARCH * HTTP/1.1\r\n"
            f"HOST: {MULTICAST_IP}:{PORT}\r\n"
            "MAN: \"ssdp:discover\"\r\n"
            f"ST: {SERVICE_TYPE}\r\n"
            f"MX: {MX}\r\n"
            "\r\n"
        )
        while not stop_discovery.is_set():
            print(
                f"[{DEVICE_NAME}] Enviando mensagem SSDP:\n{message.strip()}"
            )
            sender_socket.sendto(message.encode(), (MULTICAST_IP, PORT))
            time.sleep(5)


def ssdp_receiver():
    with socket.socket(
        socket.AF_INET,
        socket.SOCK_DGRAM,
        socket.IPPROTO_UDP
    ) as receiver_socket:
        receiver_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        receiver_socket.bind(("", PORT))

        mreq = socket.inet_aton(MULTICAST_IP) + socket.INADDR_ANY.to_bytes(
            4,
            "big"
        )
        receiver_socket.setsockopt(
            socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq
        )

        print(f"[{DEVICE_NAME}] Aguardando respostas SSDP na porta {PORT}...")

        while not stop_discovery.is_set():
            try:
                message, address = receiver_socket.recvfrom(1024)
                sender_ip = address[0]
                decoded_message = message.decode()

                if sender_ip not in discovered_devices:
                    discovered_devices.add(sender_ip)
                    print(f"[{DEVICE_NAME}] Resposta recebida de {sender_ip}:\n{decoded_message.strip()}")
                    stop_discovery.set()
            except socket.timeout:
                pass


if __name__ == "__main__":
    threading.Thread(target=ssdp_receiver, daemon=True).start()
    ssdp_sender()
```

A resposta do script acima vai se parecer com esta abaixo, informando que os dispositivos passaram pelo processo de discover.

```bash
device4  | [UPnP Device] Aguardando respostas SSDP na porta 1900...
device4  | [UPnP Device] Enviando mensagem SSDP:
device4  | M-SEARCH * HTTP/1.1
device4  | HOST: 239.255.255.250:1900
device4  | MAN: "ssdp:discover"
device4  | ST: ssdp:all
device4  | MX: 2
device4  | [UPnP Device] Resposta recebida de 1.2.8.3:
device4  | M-SEARCH * HTTP/1.1
device4  | HOST: 239.255.255.250:1900
device4  | MAN: "ssdp:discover"
device4  | ST: ssdp:all
device4  | MX: 2
device4 exited with code 0


device3  | [UPnP Device] Enviando mensagem SSDP:
device3  | M-SEARCH * HTTP/1.1
device3  | HOST: 239.255.255.250:1900
device3  | MAN: "ssdp:discover"
device3  | ST: ssdp:all
device3  | MX: 2
device3  | [UPnP Device] Aguardando respostas SSDP na porta 1900...
device3  | [UPnP Device] Enviando mensagem SSDP:
device3  | M-SEARCH * HTTP/1.1
device3  | HOST: 239.255.255.250:1900
device3  | MAN: "ssdp:discover"
device3  | ST: ssdp:all
device3  | MX: 2
device3  | [UPnP Device] Resposta recebida de 1.2.8.2:
device3  | M-SEARCH * HTTP/1.1
device3  | HOST: 239.255.255.250:1900
device3  | MAN: "ssdp:discover"
device3  | ST: ssdp:all
device3  | MX: 2
device3 exited with code 0
```

---

# Conclus√£o

O mundo do desenvolvimento n√£o se limita √†s fronteiras do c√≥digo, se permita aprofundar e olhar o que existe embaixo do cap√¥, tenho certeza de que quanto mais deep voc√™ se deixar ir, mais apaixonado voc√™ vai ficar com o que a tecnologia tem pra te mostrar. N√£o sabemos e nunca vamos saber de tudo, mas‚Ä¶ se deixe desbravar e se veja como um eterno aprendiz, algu√©m em constante evolu√ß√£o, pronto para transformar curiosidade em conhecimento e desafios em oportunidades. Afinal, a magia da tecnologia est√° justamente em sua infinita capacidade de nos surpreender e ensinar algo novo a cada dia.

Muito obrigado por ter chegado at√© aqui‚Ä¶

---

# Refer√™ncias

* Network linux
    
    * [https://wiki.archlinux.org/title/Network\_bridge](https://wiki.archlinux.org/title/Network_bridge)
        
    * [https://man7.org/linux/man-pages/man4/veth.4.html](https://man7.org/linux/man-pages/man4/veth.4.html)
        
* Docker Network
    
    * [https://docs.docker.com/engine/network/](https://docs.docker.com/engine/network/)
        
* Subnet domain
    
    * [https://en.wikipedia.org/wiki/Subnet](https://en.wikipedia.org/wiki/Subnet)
        
* Broadcast domain
    
    * [https://networklessons.com/switching/broadcast-domain](https://networklessons.com/switching/broadcast-domain)
        
* SSDP / UPNP
    
    * [https://nordvpn.com/pt-br/blog/upnp-o-que-e/](https://nordvpn.com/pt-br/blog/upnp-o-que-e/)
        
    * [https://en.wikipedia.org/wiki/Simple\_Service\_Discovery\_Protocol](https://en.wikipedia.org/wiki/Simple_Service_Discovery_Protocol)
        
* TCP range ports
    
    * [https://datatracker.ietf.org/doc/html/rfc1340](https://datatracker.ietf.org/doc/html/rfc1340)
        
    * [https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)
        
    * [https://www.rfc-editor.org/rfc/rfc6335.html](https://www.rfc-editor.org/rfc/rfc6335.html)
        
* TCP
    
    * [https://gitbook.ganeshicmc.com/redes/three-way-handshake](https://gitbook.ganeshicmc.com/redes/three-way-handshake)